#pragma once

#ifdef _WIN32
#include "GL\glew.h"
#endif

#include <map>
#include <vector>

#include <fstream>
#include <iostream>
#include <string>

class Compositor{
public:
	//Contains error
	enum error
	{
		NONE							= 0x00000000,
		PASS_NOT_FOUND					= 0x00000100,
		PASS_PROGRAM_NOT_INITIALIZED	= 0x00000101,
		PASS_OUTPUT_NOT_FOUND			= 0x00000102,
		PIPELINE_NOT_FOUND				= 0x00000200,
		PIPELINE_NOT_COMPLETE			= 0x00000201,
		SHADER_FILE_NOT_FOUND			= 0x00000300,
		SHADER_COMPILE_FAIL				= 0x00000301,
		SHADER_LINKING_FAIL				= 0x00000302,
		TEXTURE_UNIFORM_NOT_FOUND		= 0x00000400,
		TEXTURE_OUTPUT_NOT_FOUND		= 0x00000401
	};

private:

	//Contains information per pass
	struct pass{
		GLuint fbo;
		GLuint shaderFragment;
		GLuint shaderProgram;
		bool initialized;
		std::map<char*, GLuint> texInputs;		//key is uniform name in shader, value is TextureID
		std::map<int, GLuint> texOutputs;		//key is MRT output channel, value is TextureID
		GLenum *texOutputsChannels;
	};


	//Contains saved OpenGL states before rendering
	struct state{
		GLuint fbo;
		GLenum tex_active;
		std::vector<int> tex_binds;
		GLuint shaderProgram;
		GLint bufferVertexArray;
		GLint bufferArrayBuffer;
		GLboolean depthMask;
		GLfloat clearColor[4];
		GLint viewport[4];
		GLboolean alphaBlend;
	} m_state;

	//global variables

	GLuint m_width;
	GLuint m_height;
	GLuint m_shaderVertex;
	GLuint m_vertexBuffer;
	GLuint m_vertexArray;
	state m_states;
	error m_lastError;
	std::string m_shaderErrorString;
	std::map<int, pass> m_passes;					//key is Render pass ID generated by Compositor::createNewPass(), pass contains information in this pass
	std::map<int, std::vector<int>> m_pipelines;	//key is Pipeline ID generated by Compositor::createSequentialPipeline(), int contains render pass IDs in this pipeline
	
public:
	Compositor();
	~Compositor();
	error getLastError();
	std::string getLastShaderError();

	void setResolution(int, int);
	int createNewPass();
	bool loadShader(int, char*);
	bool deletePass(int);
	bool renderPass(int);

	int createSequentialPipeline();
	bool setPipeline(int, std::vector<int>);
	std::vector<int> getPipeline(int);
	bool deletePipeline(int);
	bool renderPipeline(int);

	//set uniform values
	//Can add more functions in the future handle other types of uniform (e.g. GLint, GLuint, matrix, etc. (refer to https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml)
	bool setUniformValue1f(int, char*, GLfloat);
	bool setUniformValue2f(int, char*, GLfloat, GLfloat);
	bool setUniformValue3f(int, char*, GLfloat, GLfloat, GLfloat);
	bool setUniformValue4f(int, char*, GLfloat, GLfloat, GLfloat, GLfloat);
	bool setUniformValue1i(int, char*, GLint);
	bool setUniformValue2i(int, char*, GLint, GLint);
	bool setUniformValue3i(int, char*, GLint, GLint, GLint);
	bool setUniformValue4i(int, char*, GLint, GLint, GLint, GLint);
	bool setUniformValue1ui(int, char*, GLuint);
	bool setUniformValue2ui(int, char*, GLuint, GLuint);
	bool setUniformValue3ui(int, char*, GLuint, GLuint, GLuint);
	bool setUniformValue4ui(int, char*, GLuint, GLuint, GLuint, GLuint);
	bool setUniformValue1fv(int, char*, GLfloat*);
	bool setUniformValue2fv(int, char*, GLfloat*);
	bool setUniformValue3fv(int, char*, GLfloat*);
	bool setUniformValue4fv(int, char*, GLfloat*);
	bool setUniformValue1iv(int, char*, GLint*);
	bool setUniformValue2iv(int, char*, GLint*);
	bool setUniformValue3iv(int, char*, GLint*);
	bool setUniformValue4iv(int, char*, GLint*);
	bool setUniformValue1uiv(int, char*, GLuint*);
	bool setUniformValue2uiv(int, char*, GLuint*);
	bool setUniformValue3uiv(int, char*, GLuint*);
	bool setUniformValue4uiv(int, char*, GLuint*);
	bool setUniformTexture(int, char*, GLuint);
	bool deleteUniformTexture(int, char*);
	bool setOutputTexture(int, int, GLuint);
	bool deleteOutputTexture(int, int);

private:
	void initializeVertexShader();
	void initializeBufferObject();
	void pushState();
	void popState();
	void renderPassInternal(std::map<int, pass>::iterator p);
	bool verifyPipeline(std::vector<int>);
};